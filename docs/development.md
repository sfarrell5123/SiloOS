# SiloOS Development Workflow

## The "Watch What I Did" Strategy

The most powerful way to build agents is through demonstration:

```
1. Do the task manually (with AI assistance)
2. Tell the AI to watch and learn
3. Ask it to generalize into a prompt/policy
4. Test and iterate
5. Extract the tools it used into Python
6. Deploy
```

This works because AI is exceptionally good at:
- Observing patterns in what you do
- Generalizing those patterns into reusable instructions
- Writing the code to support those instructions

### Example: Building a Refund Agent

**Step 1: Do it manually**

```
You: "Let's process a refund together. Here's a customer request..."
AI: "I'll look up the order... found it. Checking refund eligibility..."
You: "Good. Now verify their identity."
AI: "I'll check if the phone number matches... it does."
You: "Process the refund and send confirmation."
AI: "Done. Refund processed, email sent."
```

**Step 2: Ask it to watch and learn**

```
You: "Now, look at what we just did. Write a markdown policy file
      that another agent could follow to do the same thing."
```

**Step 3: Get the generalized policy**

```markdown
# Refund Processing Policy

## Steps

1. Receive customer refund request
2. Look up the order using `get_order` tool
3. Verify eligibility:
   - Order within 30 days
   - Product not final sale
   - Not previously refunded
4. Authenticate customer (phone or email verification)
5. Process refund using `process_refund` tool
6. Send confirmation using `send_email` tool with `refund-confirmation` template

## Edge Cases

- If order not found: Ask customer to verify order number
- If outside 30 days: Escalate to manager for exception consideration
- If authentication fails: Try alternative method, then escalate to human
```

**Step 4: Test and iterate**

Run test cases. When something fails or looks wrong, adjust the policy. The AI can help:

```
You: "That case didn't handle the 'item not received' scenario well.
      Update the policy to cover that."
AI: [Updates policy with new section]
```

**Step 5: Extract tools**

The AI also writes the Python tools:

```python
# tools.py - generated by AI based on what it used

@tool
def get_order(order_token: str) -> dict:
    """Look up order details by tokenized order ID."""
    return proxy.query("orders", order_token)

@tool
def process_refund(order_token: str, amount: float, reason: str) -> dict:
    """Process a refund for an order."""
    return proxy.refund(order_token, amount, reason)

@tool
def send_email(customer_token: str, template: str, vars: dict) -> dict:
    """Send templated email to customer."""
    return proxy.email(customer_token, template, vars)
```

**Step 6: Deploy**

Package the folder and deploy. The agent now handles refunds the way you showed it.

## Development Environment

### Dev Mode

In development, agents run with relaxed restrictions:

```python
# Dev environment config
{
    "mode": "development",
    "proxy": {
        "validate_keys": false,  # No key validation
        "allow_new_fields": true,  # Agent can create data structures
        "log_level": "debug"
    },
    "data": "test_database"  # Separate test data
}
```

This lets you:
- Iterate quickly without key management
- Let the agent discover what data structures it needs
- See detailed logs of everything

### Transaction Recording

The proxy can record all operations in dev mode:

```python
# Start recording
proxy.start_transaction("building-refund-agent")

# ... agent does stuff ...
# ... you iterate and test ...

# End recording
transaction = proxy.end_transaction()

# See what happened
print(transaction.operations)
# [
#   {"op": "read", "table": "orders", "fields": ["id", "amount", "status"]},
#   {"op": "read", "table": "customers", "fields": ["email_token", "phone_token"]},
#   {"op": "write", "table": "refunds", "fields": ["order_id", "amount", "reason"]},
#   {"op": "external", "service": "email", "template": "refund-confirmation"}
# ]
```

### Policy Extraction

From the transaction, extract the base keys policy:

```python
policy = transaction.to_policy()
# {
#   "data_access": {
#     "orders": {"read": ["id", "amount", "status"]},
#     "customers": {"read": ["email_token", "phone_token"]},
#     "refunds": {"write": ["order_id", "amount", "reason"]}
#   },
#   "external_services": {
#     "email": {"templates": ["refund-confirmation"]}
#   }
# }
```

This becomes the agent's base key definition. You didn't have to figure it out—you watched it happen.

## From Dev to Production

### Step 1: Freeze the Policy

Review the extracted policy:

```yaml
# agent-policy.yaml
name: refund-agent
version: 1.0.0

data_access:
  orders:
    read: [id, amount, status, customer_token, created_at]
  customers:
    read: [email_token, phone_token]
  refunds:
    write: [order_id, amount, reason, processed_by]

external_services:
  email:
    templates: [refund-confirmation, refund-denied]

limits:
  refund_amount: 500

escalation_targets:
  - manager
  - human
```

### Step 2: Generate Base Keys

From the policy, generate the JWT base key:

```bash
silo-keygen --policy agent-policy.yaml --output .keys/base.jwt
```

### Step 3: Lock Down Permissions

```bash
# Set file permissions
chmod 600 .keys/base.jwt
chown silo_refund:silo_refund .keys/base.jwt

# Set folder permissions
chmod 755 agents/refund-agent
chown -R silo_refund:silo_refund agents/refund-agent
```

### Step 4: Deploy

```bash
# Deploy to agent registry
silo-deploy agents/refund-agent

# Or just git push if using git-based deployment
git add agents/refund-agent
git commit -m "Deploy refund-agent v1.0.0"
git push
```

### Step 5: Enable in Router

```python
# Router configuration
agents["refund-agent"] = {
    "status": "active",
    "version": "1.0.0",
    "handles": ["refund_request", "return_request"],
    "fallback": "human-pool"
}
```

## Versioning and Rollback

### Version Control

Each agent folder is its own git history:

```bash
agents/refund-agent/
├── .git/                    # Version history
├── main.py
├── tools.py
├── policies/
└── ...
```

Or use a monorepo with folder-based versioning:

```bash
git log --oneline agents/refund-agent/
# abc123 Update refund limit to $500
# def456 Add email template for denied refunds
# ghi789 Initial refund-agent
```

### Instant Rollback

```bash
# Something went wrong? Rollback.
git revert HEAD
git push

# Or deploy a specific version
silo-deploy agents/refund-agent@v0.9.0
```

No deployment ceremonies. No coordination. Just revert and push.

### Blue-Green Deployment

For safer rollouts:

```python
# Route 10% of traffic to new version
agents["refund-agent"] = {
    "versions": {
        "1.0.0": {"weight": 90},
        "1.1.0": {"weight": 10}  # New version
    }
}

# Monitor, then increase
# ...later...
agents["refund-agent"]["versions"]["1.1.0"]["weight"] = 50
# ...later...
agents["refund-agent"]["versions"]["1.1.0"]["weight"] = 100
```

## Testing

### Unit Testing Policies

Test that the agent follows its policies:

```python
def test_refund_within_limit():
    """Agent should process refunds within its limit."""
    agent = RefundAgent(test_mode=True)
    result = agent.handle({
        "type": "refund_request",
        "order": test_order(amount=100),
        "reason": "defective"
    })
    assert result["status"] == "complete"
    assert result["refund_processed"] == True

def test_refund_over_limit_escalates():
    """Agent should escalate refunds over its limit."""
    agent = RefundAgent(test_mode=True)
    result = agent.handle({
        "type": "refund_request",
        "order": test_order(amount=600),  # Over $500 limit
        "reason": "defective"
    })
    assert result["status"] == "escalate"
    assert result["target"] == "manager"
```

### Integration Testing

Test agent interactions through the router:

```python
def test_refund_flow():
    """Full refund flow through router."""
    router = TestRouter()

    # Customer requests refund
    result = router.handle({
        "source": "web_chat",
        "customer": "test_customer",
        "message": "I want a refund for order #123"
    })

    # Should route to refund-agent
    assert result["agent"] == "refund-agent"
    assert "refund" in result["response"].lower()
```

### Shadow Testing

Compare new agent against production:

```python
# Route to both, compare results
shadow_config = {
    "primary": "refund-agent@1.0.0",
    "shadow": "refund-agent@1.1.0",
    "compare": True,
    "alert_on_difference": True
}
```

New version runs in shadow—its results logged but not returned to customer. If it diverges from production, you get alerted.

## Debugging

### Log Everything

Every LLM call is logged:

```json
{
  "timestamp": "2024-03-15T14:22:33Z",
  "agent": "refund-agent",
  "task_id": "task_abc123",
  "llm_call": {
    "model": "claude-3-sonnet",
    "prompt": "Customer is asking for refund on order...",
    "response": "I'll look up the order details...",
    "tokens": {"input": 450, "output": 120}
  }
}
```

### Replay Sessions

Replay a problematic session:

```bash
silo-replay --task task_abc123

# Shows step-by-step what the agent did:
# [14:22:33] Received task: refund_request
# [14:22:34] LLM call: "Looking up order..."
# [14:22:35] Tool call: get_order("ord_tk_xxx")
# [14:22:35] Tool result: {"amount": 750, "status": "delivered"}
# [14:22:36] LLM call: "Amount exceeds my limit..."
# [14:22:37] Result: escalate to manager
```

### Inspect Agent State

During development, inspect what the agent "sees":

```python
# In dev mode
agent.debug_mode = True
result = agent.handle(task)

print(agent.debug_context)
# {
#   "policies_loaded": ["how-to-refund.md", "escalation.md"],
#   "tools_available": ["get_order", "process_refund", "send_email"],
#   "task_keys": {"customer": "cust_tk_xxx", "case": "case_tk_yyy"},
#   "llm_calls": 3,
#   "tool_calls": 2
# }
```

## Best Practices

### 1. Start with Markdown

Write the policy first, then build tools to support it. Not the other way around.

### 2. Keep Tools Simple

Each tool does one thing. Let the agent compose them.

```python
# Good: Simple, composable
@tool
def get_order(order_token): ...

@tool
def check_eligibility(order): ...

@tool
def process_refund(order_token, amount): ...

# Bad: Monolithic
@tool
def handle_refund_request(customer, order, reason, ...): ...
```

### 3. Use Examples

Include example conversations in the agent folder:

```
agents/refund-agent/
├── examples/
│   ├── successful-refund.md      # Good example
│   ├── escalation-example.md     # How to escalate
│   └── edge-case-handling.md     # Tricky situations
```

The agent can reference these as few-shot examples.

### 4. Test Edge Cases

For every policy rule, write a test:

```python
# Policy says: "Escalate if customer mentions legal action"
def test_legal_threat_escalates():
    result = agent.handle({"message": "I'm going to sue you"})
    assert result["status"] == "escalate"
    assert result["target"] == "human"
```

### 5. Monitor in Production

Set up alerts for:
- Escalation rate (is it too high?)
- Error rate (is something broken?)
- Response time (is it too slow?)
- Customer satisfaction (if measurable)

```python
alerts = {
    "escalation_rate": {"threshold": 0.2, "window": "1h"},
    "error_rate": {"threshold": 0.05, "window": "15m"},
    "p95_latency": {"threshold": 5000, "window": "5m"}
}
```

## Summary

| Phase | Action |
|-------|--------|
| **Build** | Watch what I did → generalize → extract tools |
| **Dev** | Relaxed restrictions, transaction recording |
| **Test** | Unit tests, integration tests, shadow testing |
| **Deploy** | Git push, instant rollback |
| **Monitor** | Logs, replays, alerts |

The workflow is designed for speed and safety: build by demonstration, test thoroughly, deploy instantly, rollback easily. No ceremonies, no coordination, no waiting.
